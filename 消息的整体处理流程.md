# 消息的整体处理流程是：
1. 大部分消息会在正常消费者那里就被处理掉，消息正确处理后，就会执行 ack 将消息从 PEL 中删除（是的，只有 ack 才会让消息从 PEL 中删除，delete 操作好像只是删除 stream 中的消息，消息是有两份的）
2. 如果正常消费者出现了异常，没有执行 ack，那么该消息在 PEL 中会存在，且该消息属于正常消费者，因为 PEL 消费者是只读 PEL 队列中属于自己的消息，所以此时该消息还不会被 PEL 读到
3. 死循环 xcliam 线程不断从 PEL 队头开始检查超过 3s 的消息，将这些消息重新 xcliam 给 PEL 消消费者，从而能被 PEL 消费者监听到并处理。
4. 消息被 xcliam 给 PEL 消费者后，PEL 消费者就能进行处理，如果处理成功，就执行 ack，从而消息彻底从 PEL 中删除。如果处理失败，那么 PEL 消费者会将消息重新 xcliam 给正常消费者（其实 xcliam 给任何人都行，这里主要是将消息的所属权转移出去，避免 PEL 消费者反复从队头读取该消息）
5. PEL 消费者将消息 xcliam 给正常消费者以后，其实正常消费者并不会去读 PEL，正常消费者只会以消费者组形式读 stream，从而这条消息在 PEL 中会空闲，超过 3s 后，就会被前面提到的死循环线程重新 xcliam 给 PEL，这样消息就是 3s 后重新可以被 PEL 消费者处理，在 PEL 消费者这里通过 xcliam 和 xpending 机制实现了一种重复投递的效果。
