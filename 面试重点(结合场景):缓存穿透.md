# 缓存穿透

大量的请求去查询一个在缓存中不存在的数据（数据库中也不存在），由于缓存不命中，就会去请求数据库，这将会导致大量的请求打到数据库上，造成数据库压力过大

缓存是为了提高数据访问速度，避免频繁访问数据库，但如果攻击者故意请求缓存中不存在的数据，会导致缓存不命中，请求直接访问数据库。


<img width="866" height="635" alt="image" src="https://github.com/user-attachments/assets/89a2b2ab-b989-4dfb-aa8b-48825439cf89" />


有以下几种方法：

### 一：引入空对象值缓存
即如果请求数据查询不存在时，也将结果存储在缓存中，即原来是short-link_goto_%s(%s指的是完整短链接)，查询到不存在时，我们将short-link_is-null_goto_%s(%s指完整短链接)也存入到缓存中，这样后面如果同样的请求打过来时，如果读取到短链接对应的短链接跳转空key时，就直接返回404，即不存在该短链接。  

但是这样也有弊端，如果有恶意攻击，他使用大量的随机生成的不存在于数据库中更不会存在于缓存中的短链接，比方说攻击者每秒访问1000个短链接，如果我们设置一个空key过期时间为30分钟，
那么在这30分钟就会生成1000 * 60 * 30 = 1800 000 个短链接，即使每个空key缓存（无用的空缓存）key+value仅占200B，1800 000 也会有大约360MB的Redis内存占用，我们知道Redis内存是很珍贵的

而且这些key都是无用的垃圾数据。

<img width="884" height="834" alt="image" src="https://github.com/user-attachments/assets/a49882a2-2dc9-4748-b0b2-e11714aae68a" />



### 二：引入分布式锁
即大量同样的请求访问缓存不存在，这时候当第一个请求访问数据库时，使用基于Redisson的分布式锁上锁，使得它先去数据库里访问完了发现也没有然后才会轮到第二个请求，这样就是原来大量相同请求并发访问数据库的形式强制变成了串行访问，因此是降低了数据库的压力，但是如果是缓存击穿的场景，也就是缓存中不存在但是数据库中存在，一个请求访问数据库发现存在，可能因为这是热点短链接，
就会有很多的请求在等待锁（本来是正常的请求，却平白无故被加上了锁，因此是被误杀）


<img width="883" height="527" alt="image" src="https://github.com/user-attachments/assets/f97941eb-ba93-4cc5-866a-d77d64ab6527" />


### 三：布隆过滤器
因为布隆过滤器是主要是判断是否存在集合中，如果要获取原始链接仍然需要访问数据库，因此采取的措施是先访问缓存，如果缓存中没有，在访问布隆过滤器（应用启动的时候已经将所有合法的数据存入到布隆过滤器中了)，
存入的这个过程会很快，因为哈希函数非常轻量
一般用 MurmurHash / FNV / BKDR 等非加密哈希
计算复杂度 O(1)
CPU 可以轻松处理几千万次哈希运算）
这时候的流程就是，如果布隆过滤器中没有则一定没有，直接返回404，如果布隆过滤器中有，则去访问数据库，正常返回然后把获取到的数据重新写入到redis缓存中，这样之后的请求访问缓存就能直接返回。

但是也有弊端：即如果它是一种误判的情况，即在数据库中不存在的短链接但是布隆过滤器判存在了，这时候如果有大量恶意的请求同时访问这个短链接，还是会直接导致大量请求访问数据库


<img width="882" height="790" alt="image" src="https://github.com/user-attachments/assets/682978a5-0701-4966-81f1-c99600447a53" />

### 四：多种组合

布隆过滤器我们发现很好了已经，只是无法预防这种误判的场景；因此我们在布隆过滤器判为存在时，我们先不去访问数据库，先是去缓存中判断是否存在key为空的对象也就是short-link_is-null-goto%s是否存在（因为这个空key是我们在访问了数据库之后不存在的时候才会设置的，他不存在误判的情况），如果存在我们直接返回404，不存在我们再去访问数据库；这时候防止并发的大量相同的请求，因此我们加上一层分布式锁，只允许一条请求进入数据库查询，如果存在，则写回缓存，之后的请求都可以直接从一开始的缓存中获取到原始链接，如果不存在，则将数据为空的key写入到缓存中也就是short-link_is-null-goto%s；这样之后的请求就会先访问缓存中存在的key，不存在然后再访问布隆过滤器（可能仍误判）再访问空key然后返回404即可。和之前缓存击穿一样对正常缓存设置双重判定锁一样，我们这里对空值缓存key也要双重判定锁。







<img width="875" height="634" alt="image" src="https://github.com/user-attachments/assets/83e6f1b3-2427-40e4-9285-0e5564610efd" />
